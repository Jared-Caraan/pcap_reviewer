### The inner life of lists

Now we want to show you one important, and very surprising, feature of lists, which strongly distinguishes them from ordinary variables.

We want you to memorize it - it may affect your future programs, and cause severe problems if forgotten or overlooked.

Take a look at the snippet in the editor.

```python
list_1 = [1]
list_2 = list_1
list_1[0] = 2
print(list_2)
```

The program:

- creates a one-element list named `list_1`;
- assigns it to a new list named `list_2`;
- changes the only element of `list_1`;
- prints out `list_2`.

The surprising part is the fact that the program will output: `[2]`, not `[1]`, which seems to be the obvious solution.

Lists (and many other complex Python entities) are stored in different ways than ordinary (scalar) variables.

You could say that:

- the name of an ordinary variable is the **name of its content**;
- the name of a list is the name of a **memory location where the list is stored**.

Read these two lines once more - the difference is essential for understanding what we are going to talk about next.

The assignment: `list_2 = list_1` copies the name of the array, not its contents. In effect, the two names (`list_1` and `list_2`) identify the same location in the computer memory. Modifying one of them affects the other, and vice versa.

How do you cope with that?
<hr>

### Powerful slices

Fortunately, the solution is at your fingertips - its name is the **slice**.

A slice is an element of Python syntax that allows you to **make a brand new copy of a list, or parts of a list.**

It actually copies the list's contents, not the list's name.

This is exactly what you need. Take a look at the snippet below:

```python
list_1 = [1]
list_2 = list_1[:]
list_1[0] = 2
print(list_2)
```

Its output is `[1]`.

This inconspicuous part of the code described as `[:]` is able to produce a brand new list.
<hr>

One of the most general forms of the slice looks as follows:

`my_list[start:end]`

As you can see, it resembles indexing, but the colon inside makes a big difference.

A slice of this form **makes a new (target) list, taking elements from the source list - the elements of the indices from start to** `end - 1`.

> [!NOTE]
> not to `end` but to `end - 1`. An element with an index equal to `end` is the first element which **does not take part in the slicing**.

Using negative values for both start and end is possible (just like in indexing).

Take a look at the snippet:

```python
my_list = [10, 8, 6, 4, 2]
new_list = my_list[1:3]
print(new_list)
```

The `new_list` list will have `end - start` (3 - 1 = 2) elements - the ones with indices equal to `1` and `2` (but not `3`).

The snippet's output is: `[8, 6]`
